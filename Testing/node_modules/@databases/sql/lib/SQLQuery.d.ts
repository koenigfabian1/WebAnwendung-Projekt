/**
 * A Postgres query which may be fed directly into the `pg` module for
 * execution.
 */
export interface PGQuery {
    /**
     * The SQL query text with placeholders for values. The placeholders refer to
     * a value in the `values` array.
     */
    text: string;
    /**
     * The values used to fill the placeholders in `text`.
     */
    values: Array<any>;
}
/**
 * A MySQL query which may be fed directly into the `mysql2` module for
 * execution.
 */
export interface MySqlQuery {
    /**
     * The SQL query text with placeholders for values. The placeholders refer to
     * a value in the `values` array.
     */
    text: string;
    /**
     * The values used to fill the placeholders in `text`.
     */
    values: Array<any>;
}
export declare type MinifyFunction = (src: string) => string;
export declare type ReadFileSync = (filename: string, format: 'utf8') => string;
export declare function setPgMinify(minify: MinifyFunction): void;
export declare function setReadFileSync(readFileSyncArg: ReadFileSync): void;
/**
 * The representation of a SQL query. Call `compile` to turn it into a SQL
 * string with value placeholders.
 *
 * This object is immutable. Instead of changing the object, new `SQLQuery`
 * values will be returned.
 *
 * The constructor for this class is private and may not be called.
 */
export default class SQLQuery implements PGQuery {
    static registerFormatter<T>(constructor: new (...args: any[]) => T, format: (value: T) => SQLQuery): void;
    /**
     * A template string tag that interpolates literal SQL with placeholder SQL
     * values.
     */
    static query(strings: TemplateStringsArray, ...values: Array<any>): SQLQuery;
    /**
     * Joins multiple queries together and puts a separator in between if a
     * separator was defined.
     */
    static join(queries: Array<SQLQuery>, separator?: SQLQuery): SQLQuery;
    /**
     * Joins multiple queries together and puts a separator in between if a
     * separator was defined.
     */
    static join(queries: Array<SQLQuery>, separator: ',' | ', ' | ' AND ' | ' OR ' | ') AND (' | ') OR (' | ';'): SQLQuery;
    /**
     * Joins multiple queries together and puts a separator in between if a
     * separator was defined.
     *
     * @deprecated please do not pass the separator as a string, use sql`` to mark it as an SQL string
     */
    static join(queries: Array<SQLQuery>, separator: string): SQLQuery;
    /**
     * Creates a new query with the contents of a utf8 file
     */
    static file(filename: string): SQLQuery;
    /**
     * Creates a new query with the raw text.
     */
    static raw(text: string): SQLQuery;
    /**
     * Creates a new query with the value. This value will be turned into a
     * placeholder when the query gets compiled.
     */
    static value(value: any): SQLQuery;
    /**
     * Creates an identifier query. Each name will be escaped, and the
     * names will be concatenated with a period (`.`).
     */
    static ident(...names: Array<any>): SQLQuery;
    /**
     * The internal array of SQL items. This array is never mutated, only cloned.
     */
    private readonly _items;
    /**
     * Storage for our memoized compiled query.
     */
    private _pgQuery;
    private _pgQueryMinified;
    /**
     * Storage for our memoized compiled query.
     */
    private _mysqlQuery;
    private constructor();
    /**
     * The SQL query text with placeholders for values. The placeholders refer to
     * a value in the `values` array.
     */
    readonly text: string;
    /**
     * The values used to fill the placeholders in `text`.
     */
    readonly values: Array<any>;
    /**
     * Compiles this SQL query into a Postgres query. Memoized so it only does the
     * work once.
     */
    compile(options?: {
        minify: boolean;
    }): PGQuery;
    /**
     * Compiles this SQL query into a Postgres query. Memoized so it only does the
     * work once.
     */
    compileMySQL(): MySqlQuery;
}
