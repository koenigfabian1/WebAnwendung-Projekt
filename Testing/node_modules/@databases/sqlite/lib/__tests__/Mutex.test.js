"use strict";

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mutex_1 = require("../Mutex");
function delay(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        yield new Promise(resolve => setTimeout(resolve, ms));
    });
}
test('Allows parallel read queries', () => __awaiter(void 0, void 0, void 0, function* () {
    const mutex = new Mutex_1.default();
    const results = [];
    yield Promise.all([mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R1');
        yield delay(100);
        results.push('END R1');
    })), mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R2');
        yield delay(300);
        results.push('END R2');
    })), mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R3');
        yield delay(200);
        results.push('END R3');
    }))]);
    expect(results).toMatchInlineSnapshot(`
Array [
  "START R1",
  "START R2",
  "START R3",
  "END R1",
  "END R3",
  "END R2",
]
`);
}));
test('Only Allows One Write', () => __awaiter(void 0, void 0, void 0, function* () {
    const mutex = new Mutex_1.default();
    const results = [];
    yield Promise.all([mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R1');
        yield delay(100);
        results.push('END R1');
    })), mutex.writeLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START W1');
        yield delay(100);
        results.push('END W1');
    })), mutex.writeLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START W2');
        yield delay(100);
        results.push('END W2');
    })), mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R2');
        yield delay(300);
        results.push('END R2');
    })), mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R3');
        yield delay(200);
        results.push('END R3');
    })), mutex.writeLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START W3');
        yield delay(100);
        results.push('END W3');
    }))]);
    const a = [mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R4');
        yield delay(300);
        results.push('END R4');
    })), mutex.writeLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START W4');
        yield delay(100);
        results.push('END W4');
    }))];
    yield delay(200);
    yield Promise.all([...a,
    // because W4 has already been waiting for 200ms
    // this read queues behind it instead of jumping
    // the queue like R2 and R3 did
    mutex.readLock(() => __awaiter(void 0, void 0, void 0, function* () {
        results.push('START R5');
        yield delay(300);
        results.push('END R5');
    }))]);
    expect(results).toMatchInlineSnapshot(`
Array [
  "START R1",
  "START R2",
  "START R3",
  "END R1",
  "END R3",
  "END R2",
  "START W1",
  "END W1",
  "START W2",
  "END W2",
  "START W3",
  "END W3",
  "START R4",
  "END R4",
  "START W4",
  "END W4",
  "START R5",
  "END R5",
]
`);
}));
//# sourceMappingURL=Mutex.test.js.map