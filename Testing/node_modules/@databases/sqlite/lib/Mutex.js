"use strict";

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class Mutex {
    constructor(maxWaitTimeout = 100) {
        this.tasks = [];
        this.running = 0;
        this.runningWrite = false;
        this._taskStart = runningWrite => {
            this.running++;
            this.runningWrite = runningWrite;
        };
        this._taskEnd = () => {
            this.running--;
            this.runningWrite = false;
            while (this.tasks.length && !this.tasks[0].write) {
                this._taskStart(false);
                this.tasks.shift().fn().then(this._taskEnd, this._taskEnd);
            }
            if (!this.running && this.tasks.length) {
                this._taskStart(true);
                this.tasks.shift().fn().then(this._taskEnd, this._taskEnd);
            }
        };
        this.maxWaitTimeout = maxWaitTimeout;
    }
    readLock(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const now = Date.now();
            if (this.runningWrite || this.tasks.some(t => t.write && now - t.start > this.maxWaitTimeout)) {
                return new Promise((resolve, reject) => {
                    this.tasks.push({
                        start: now,
                        write: false,
                        fn: () => __awaiter(this, void 0, void 0, function* () {
                            try {
                                resolve((yield fn()));
                            } catch (ex) {
                                reject(ex);
                            }
                        })
                    });
                });
            } else {
                this._taskStart(false);
                try {
                    return yield fn();
                } finally {
                    this._taskEnd();
                }
            }
        });
    }
    writeLock(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.running) {
                return new Promise((resolve, reject) => {
                    this.tasks.push({
                        start: Date.now(),
                        write: true,
                        fn: () => __awaiter(this, void 0, void 0, function* () {
                            try {
                                resolve((yield fn()));
                            } catch (ex) {
                                reject(ex);
                            }
                        })
                    });
                });
            } else {
                this._taskStart(true);
                try {
                    return yield fn();
                } finally {
                    this._taskEnd();
                }
            }
        });
    }
}
exports.default = Mutex;
//# sourceMappingURL=Mutex.js.map