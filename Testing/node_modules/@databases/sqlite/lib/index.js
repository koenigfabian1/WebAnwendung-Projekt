"use strict";

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = undefined && undefined.__await || function (v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = undefined && undefined.__asyncGenerator || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function (v) {
            return new Promise(function (a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
const sqlite = require("sqlite3");
const sql_1 = require("@databases/sql");
exports.sql = sql_1.default;
exports.SQLQuery = sql_1.SQLQuery;
const Mutex_1 = require("./Mutex");
const Queue = require('then-queue');
var DatabaseConnectionMode;
(function (DatabaseConnectionMode) {
    DatabaseConnectionMode[DatabaseConnectionMode["ReadOnly"] = sqlite.OPEN_READONLY] = "ReadOnly";
    DatabaseConnectionMode[DatabaseConnectionMode["ReadWrite"] = sqlite.OPEN_READWRITE] = "ReadWrite";
    // tslint:disable-next-line:no-bitwise
    DatabaseConnectionMode[DatabaseConnectionMode["ReadWriteCreate"] = sqlite.OPEN_READWRITE | sqlite.OPEN_CREATE] = "ReadWriteCreate";
    // tslint:disable-next-line:no-bitwise
    DatabaseConnectionMode[DatabaseConnectionMode["ReadCreate"] = sqlite.OPEN_READONLY | sqlite.OPEN_CREATE] = "ReadCreate";
    DatabaseConnectionMode[DatabaseConnectionMode["Create"] = sqlite.OPEN_CREATE] = "Create";
})(DatabaseConnectionMode = exports.DatabaseConnectionMode || (exports.DatabaseConnectionMode = {}));
class DatabaseTransactionImplementation {
    constructor(database) {
        this._database = database;
    }
    query(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return runQuery(query, this._database, fn => __awaiter(this, void 0, void 0, function* () {
                return fn();
            }));
        });
    }
    /**
     * @deprecated use queryStream
     */
    stream(query) {
        return this.queryStream(query);
    }
    queryStream(query) {
        return runQueryStream(query, this._database, fn => __awaiter(this, void 0, void 0, function* () {
            return fn();
        }));
    }
}
exports.IN_MEMORY = ':memory:';
class DatabaseConnectionImplementation {
    constructor(filename, options = {}) {
        this._mutex = new Mutex_1.default();
        this._database = new sqlite.Database(filename, options.mode);
        if (options.verbose) {
            sqlite.verbose();
        }
        if (options.busyTimeout !== undefined) {
            this._database.configure('busyTimeout', options.busyTimeout);
        }
    }
    query(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return runQuery(query, this._database, fn => __awaiter(this, void 0, void 0, function* () {
                return this._mutex.readLock(fn);
            }));
        });
    }
    /**
     * @deprecated use queryStream
     */
    stream(query) {
        return this.queryStream(query);
    }
    queryStream(query) {
        return runQueryStream(query, this._database, fn => __awaiter(this, void 0, void 0, function* () {
            return this._mutex.readLock(fn);
        }));
    }
    tx(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._mutex.writeLock(() => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((resolve, reject) => {
                    this._database.run('BEGIN', err => {
                        if (err) reject(err);else resolve();
                    });
                });
                try {
                    const result = fn(new DatabaseTransactionImplementation(this._database));
                    yield new Promise((resolve, reject) => {
                        this._database.run('COMMIT', err => {
                            if (err) reject(err);else resolve();
                        });
                    });
                    return result;
                } catch (ex) {
                    yield new Promise((resolve, reject) => {
                        this._database.run('REVERT', err => {
                            if (err) reject(err);else resolve();
                        });
                    });
                    throw ex;
                }
            }));
        });
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                this._database.close(err => {
                    if (err) reject(err);else resolve();
                });
            });
        });
    }
}
function connect(filename = exports.IN_MEMORY, options = {}) {
    return new DatabaseConnectionImplementation(filename, options);
}
exports.default = connect;
module.exports = Object.assign(connect, {
    default: connect,
    DatabaseConnectionMode,
    IN_MEMORY: exports.IN_MEMORY,
    sql: sql_1.default,
    SQLQuery: sql_1.SQLQuery
});
function runQuery(query, database, lock) {
    return __awaiter(this, void 0, void 0, function* () {
        const { text, values } = query.compileMySQL();
        return lock(() => __awaiter(this, void 0, void 0, function* () {
            return yield new Promise((resolve, reject) => {
                database.all(text, values, (err, rows) => {
                    if (err) reject(err);else resolve(rows);
                });
            });
        }));
    });
}
function runQueryStream(query, database, lock) {
    return __asyncGenerator(this, arguments, function* runQueryStream_1() {
        const queue = new Queue();
        const { text, values } = query.compileMySQL();
        lock(() => __awaiter(this, void 0, void 0, function* () {
            yield new Promise(releaseMutex => {
                database.each(text, values, (err, row) => {
                    if (err) queue.push({ done: true, err });else queue.push({ done: false, value: row });
                }, err => {
                    releaseMutex();
                    queue.push({ done: true, err });
                });
            });
        })).catch(ex => {
            setImmediate(() => {
                throw ex;
            });
        });
        let value = yield __await(queue.pop());
        while (!value.done) {
            yield yield __await(value.value);
            value = yield __await(queue.pop());
        }
    });
}
//# sourceMappingURL=index.js.map